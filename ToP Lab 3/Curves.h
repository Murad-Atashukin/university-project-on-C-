#ifndef _CURVES_H_		
#define _CURVES_H_	/* Тк дириктива include просто берёт и вставляет код из библиотеке, которую мы подключаем,
					то возникает проблема повторного включения кода в проект, что раздувает размер нашего исходника.
					Условие ifndef необходимо для того, чтобы узнать, добавляли ли мы этот участок
					кода в наш проект или нет. Если константа определена, то повторного добавления не будет
				    Определяем константу */

#include <iostream>
#include <cmath>

class Curves
{
protected:
	double x;

public:
	Curves() { x = 0; };
	virtual ~Curves() {};	/* Создаём виртуальный деструктор(в данной программе он не нужен, достаточно и деструктора по

умолчанию, но в других случаях он может понадобиться. Например, когда в каком-то из конструкторов
мы выделяем память через оператора new, а в деструкторе освобождаем. Всё будет прекрасно работать
и с обычным деструктором, до того момента, когда мы захотим в указатель на базовый класс присвоить
класс наследник. У нас всё по-прежнему будет работать, но при выходе из программы произойдёт утечка 
памяти, тк отчистка проиходила в деструкторе базового класса, а он не будет вызываться у наследника.
Чтобы такой проблемы не было и нужен виртуальный деструктор.*/
											
											// Пример выделения: Base* a = new Heir; где а - это указатель на базовый класс
	virtual void print() = 0;				// Виртуальная функция print(). = 0 означает, что определения этой функции в данном классе не будет,
											// а следовательно, данный класс будет абстрактным. Объект Абстрактного класса нельзя создать.
											// От этого класса можно только унаследоваться.
											// Виртуальные ф-ии нужны для полиморфизма программы, т.е., если мы имеем какой-то базовый класс А, и 
											// его наследника Б, но реализация какого-то метода в Б должна быть немного другой, то мы можем просто
											// переопределить этот метод (ВАЖНО: тип возвращаемого значения и количество принимаемых параметров 
											// должны быть во всех классах одинаковы, иначе мы не переопределим данный метод, а создадим новый,
											// не имеющий ничего общего с унаследованным)

	virtual double function_for_y() = 0;	// При объявлении виртуальной функции создаётся виртуальная таблица (vtable), в которой находится
											// информация обо всех виртуальных ф-ях этого класса. Количество vtable равно количеству классов с
											// виртуальными ф-ями. В памяти хранение происходит следующим образом:
											// [Указатель на vtable][поля и методы данного класса]
											// Хоть и виртуальные функции - довольно полезная вещь, но они довольно много занимают 8 байт (тк указатель)
											// и из-за них скорость работы немного замедляется, тк, чтобы узнать об реализации данной ф-ии,
											// компилятору нужно сначало перейти по адресу в эту таблицу, и оттуда прыгнуть в место реализации.
};
#endif // !_CURVES_H_